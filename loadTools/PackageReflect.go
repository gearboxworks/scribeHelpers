/*
Problem: Go reflection does not support enumerating types, variables and functions of packages.

pkgreflect generates a file named pkgreflect.go in every parsed package directory.
This file contains the following maps of exported names to reflection types/values:

	var Types = map[string]reflect.Type{ ... }
	var Functions = map[string]reflect.Value{ ... }
	var Variables = map[string]reflect.Value{ ... }

Command line usage:

	pkgreflect --help
	pkgreflect [-notypes][-nofuncs][-novars][-unexported][-norecurs][-gofile=filename.go] [DIR_NAME]

If -norecurs is not set, then pkgreflect traverses recursively into sub-directories.
If no DIR_NAME is given, then the current directory is used as root.
*/
package loadTools

import (
	"bytes"
	"fmt"
	"github.com/newclarity/scribeHelpers/ux"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"
)


type PkgReflect struct {
	//Paths      []toolPath.TypeOsPath

	Notypes    bool		// "Don't list package types"
	Nofuncs    bool		// "Don't list package functions"
	Novars     bool		// "Don't list package variables"
	Noconsts   bool		// "Don't list package consts"
	Unexported bool		// "Also list unexported names"
	Norecurs   bool		// "Don't parse sub-directories resursively"
	Stdout     bool		// "Name of the generated .go file"
	Gofile     string	// "Write to stdout."
	Notests    bool		// "Don't list test related code"

	Debug      bool
	State      *ux.State
}


func PackageReflect(pr PkgReflect, paths ...string) *ux.State {

	for range OnlyOnce {
		pr.State = ux.NewState("scribe", false)

		if pr.Gofile == "" {
			pr.Gofile = "pkgreflect.go"
		}

		if len(paths) == 0 {
			pr.State.SetError("PackageReflect: No paths defined.")
			break
		}

		for _, p := range paths {
			pr.State = pr.parseDir(p)
			if pr.State.IsNotOk() {
				break
			}
		}
	}

	return pr.State
}


func (pr *PkgReflect) parseDir(dir string) *ux.State {

	for range OnlyOnce {
		dirFile, err := os.Open(dir)
		if err != nil {
			pr.State.SetError("PackageReflect: Cannot open directory '%s'", dir)
			break
		}
		//noinspection ALL
		defer dirFile.Close()

		info, err := dirFile.Stat()
		if err != nil {
			pr.State.SetError("PackageReflect: Cannot stat directory '%s'", dir)
			break
		}
		if !info.IsDir() {
			pr.State.SetError("PackageReflect: Filename '%s' is not a directory.", dir)
			break
		}

		pkgs, err := parser.ParseDir(token.NewFileSet(), dir, pr.filter, 0)
		if err != nil {
			pr.State.SetError("PackageReflect: Cannot parse - %s", err)
			break
		}

		for _, pkg := range pkgs {
			var buf bytes.Buffer

			_, _ = fmt.Fprintln(&buf, "// Code generated by github.com/newclarity/PackageReflect DO NOT EDIT.")
			_, _ = fmt.Fprintln(&buf, "")
			_, _ = fmt.Fprintln(&buf, "package", pkg.Name)
			_, _ = fmt.Fprintln(&buf, "")
			_, _ = fmt.Fprintln(&buf, `import "reflect"`)
			_, _ = fmt.Fprintln(&buf, "")

			// Types
			if !pr.Notypes {
				_, _ = fmt.Fprintln(&buf, "var Types = map[string]reflect.Type{")
				pr.print(&buf, pkg, ast.Typ, "\t\"%s\": reflect.TypeOf((*%s)(nil)).Elem(),\n")
				_, _ = fmt.Fprintln(&buf, "}")
				_, _ = fmt.Fprintln(&buf, "")
			}

			// Functions
			if !pr.Nofuncs {
				_, _ = fmt.Fprintln(&buf, "var Functions = map[string]reflect.Value{")
				pr.print(&buf, pkg, ast.Fun, "\t\"%s\": reflect.ValueOf(%s),\n")
				_, _ = fmt.Fprintln(&buf, "}")
				_, _ = fmt.Fprintln(&buf, "")
			}

			if !pr.Novars {
				// Addresses of variables
				_, _ = fmt.Fprintln(&buf, "var Variables = map[string]reflect.Value{")
				pr.print(&buf, pkg, ast.Var, "\t\"%s\": reflect.ValueOf(&%s),\n")
				_, _ = fmt.Fprintln(&buf, "}")
				_, _ = fmt.Fprintln(&buf, "")
			}

			if !pr.Noconsts {
				// Addresses of consts
				_, _ = fmt.Fprintln(&buf, "var Consts = map[string]reflect.Value{")
				pr.print(&buf, pkg, ast.Con, "\t\"%s\": reflect.ValueOf(%s),\n")
				_, _ = fmt.Fprintln(&buf, "}")
				_, _ = fmt.Fprintln(&buf, "")
			}

			if pr.Stdout {
				_, err = io.Copy(os.Stdout, &buf)
				if err != nil {
					pr.State.SetError("PackageReflect: Cannot write to stdout - %s", err)
					break
				}

			} else {
				filename := filepath.Join(dir, pr.Gofile)
				newFileData := buf.Bytes()
				oldFileData, _ := ioutil.ReadFile(filename)
				if !bytes.Equal(newFileData, oldFileData) {
					err = ioutil.WriteFile(filename, newFileData, 0660)
					if err != nil {
						pr.State.SetError("PackageReflect: Cannot write to file '%s' - %s", filename, err)
						break
					}
				}
			}
		}

		if !pr.Norecurs {
			dirs, err := dirFile.Readdir(-1)
			if err != nil {
				pr.State.SetError("PackageReflect: Cannot reach directory '%s' - %s", dirs, err)
				break

			}
			for _, info := range dirs {
				if info.IsDir() {
					pr.State = pr.parseDir(filepath.Join(dir, info.Name()))
				}
			}
		}
	}

	return pr.State
}


func (pr *PkgReflect) print(w io.Writer, pkg *ast.Package, kind ast.ObjKind, format string) *ux.State {

	for range OnlyOnce {
		var names []string
		for _, f := range pkg.Files {
			for name, object := range f.Scope.Objects {
				if object.Kind == kind && (pr.Unexported || ast.IsExported(name)) {
					names = append(names, name)
				}
			}
		}

		sort.Strings(names)
		for _, name := range names {
			_, _ = fmt.Fprintf(w, format, name, name)
		}
	}

	return pr.State
}


func (pr *PkgReflect) filter(info os.FileInfo) bool {
	var ok bool

	for range OnlyOnce {
		name := info.Name()

		if info.IsDir() {
			break
		}

		if name == pr.Gofile {
			break
		}

		if filepath.Ext(name) != ".go" {
			break
		}

		if strings.HasSuffix(name, "_test.go") && pr.Notests {
			break
		}

		ok = true
	}

	return ok
}
